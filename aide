#!/usr/bin/env python3
import datetime
import logging
import os
import coloredlogs
import sqlite3
import matplotlib.pyplot as plt

from arguments import get_arguments


def set_logging(verbose=False):
    os.environ['COLOREDLOGS_LOG_FORMAT'] = '%(levelname)-8s %(message)s'
    coloredlogs.install(
        level=logging.INFO if not verbose else logging.DEBUG,
        datefmt="%m-%d %H:%M:%S"
    )


def add_task(args, db, cursor):
    logging.info("Adding %s; priority %s; start time %s" % (args.name, args.priority, args.time))

    priority = args.priority
    if args.time:
        priority += 100

    repeat = "+" + args.repeat if args.repeat else None

    cursor.execute("INSERT INTO tasks(name, priority, due_time, weight, repeat_period) VALUES ("
                   "?, "
                   "?, "
                   # this ugly line is conversion from local time to utc; I couldn't make it work with cleaner methods
                   "time(strftime('%s', ?) + strftime('%s', 'now') - strftime('%s', 'now', 'localtime'), 'unixepoch'), "
                   "?, "
                   "?)",
                   (args.name, priority, args.time, args.weight, repeat))
    db.commit()


def list_tasks(args, cursor):
    query = "SELECT id, name, priority, strftime('%H:%M', due_time, 'localtime'), status, weight FROM tasks WHERE "
    query_arguments = []

    if args.top:
        query = "SELECT id, name, priority, strftime('%H:%M', due_time, 'localtime'), status, weight FROM tasks " \
                "WHERE status=1 AND (due_time < current_time OR due_time IS NULL) AND due_date = current_date " \
                " ORDER BY priority DESC " \
                " LIMIT 1"
    else:
        if args.date:
            query += "due_date=? "
            query_arguments.append(args.date)
        else:
            query += "due_date=current_date "

        if args.open:
            query += "AND status=1 "

    cursor.execute(query, query_arguments)
    result = cursor.fetchall()
    print_tasks(result, verbose=args.verbose)


def modify_task(args, db, cursor):
    logging.info("Modifying task: " + args.id)

    setters = []
    query_arguments = []

    if args.name:
        setters.append("name=?")
        query_arguments.append(args.name)

    if args.priority >= 0:
        setters.append("priority=?")
        query_arguments.append(args.priority)

    if args.time:
        setters.append("due_time=?")
        query_arguments.append(args.time)

    if args.weight >= 0:
        setters.append("weight=?")
        query_arguments.append(args.weight)

    if args.repeat:
        setters.append("repeat_period=?")
        query_arguments.append("+" + args.repeat)

    if args.date:
        date = relative_date_to_sql_query(args.date)
        setters.append("due_date=" + date)

    query = "UPDATE tasks SET " + " AND ".join(setters) + " WHERE id = ?"
    query_arguments.append(args.id)

    cursor.execute(query, query_arguments)
    db.commit()


def postpone_task(args, db, cursor):
    logging.info("Postponing task: " + args.id)
    cursor.execute("UPDATE tasks SET due_date = date(due_date, ?) WHERE id = ?", ("+" + args.interval, args.id))
    db.commit()


def close_task(args, db, cursor):
    logging.info("Closing task: " + args.id)

    # if args.id == "99":
    #     cursor.execute(
    #         "UPDATE tasks SET status=0 "
    #         "WHERE priority=( "
    #             "SELECT MAX(priority) FROM tasks WHERE due_date=current_date AND status=1 "
    #         ") AND status=1 "
    #         "LIMIT 1")
    # else:
    cursor.execute("UPDATE tasks SET status=0 WHERE id = ?", (args.id,))
    db.commit()


def delete_task(args, db, cursor):
    logging.info("Deleting task: " + args.id)
    cursor.execute("DELETE FROM tasks WHERE id = ?", (args.id,))
    db.commit()


def report(args, cursor):
    if args.plot:
        cursor.execute('SELECT sum(weight),due_date FROM tasks WHERE status=0 GROUP BY due_date')
        data = cursor.fetchall()

        if len(data) <= 2:
            logging.error("Not enough data to build a plot")
            return

        date_start = datetime.datetime.strptime(data[0][1], "%Y-%m-%d")
        date_end = datetime.datetime.strptime(data[-1][1], "%Y-%m-%d")
        dates = [(date_start + datetime.timedelta(days=x)).strftime("%Y-%m-%d") for x in
                 range(0, (date_end - date_start).days + 1)]

        weights = []
        i = 0
        for row in data:
            while row[1] != dates[i]:
                weights.append(0.0)
                i += 1

            weights.append(row[0])
            i += 1

        fig = plt.figure(figsize=(10, 1))
        ax = fig.add_subplot(111)
        ax.bar(dates, weights)
        labels = ax.set_xticklabels(dates)
        plt.setp(labels, rotation=90)
        ax.set_aspect(3.)
        plt.show()

        return

    query = "SELECT sum(weight) FROM tasks WHERE due_date=current_date GROUP BY due_date"
    query_arguments = []

    result = cursor.execute(query, query_arguments).fetchone()
    total = result[0] if result else 0.0

    print("Total weight:", total)


def print_tasks(tasks: list, verbose=True):
    if not tasks:
        print("No open tasks")
        return

    if not verbose:
        print(tasks[0][1])
        return

    for row in tasks:
        due = row[3] if row[3] else "--:--"
        print("{:<2} | Pr: {:<3} | Status: {} | Weight: {:<4} | Due: {} | {}".format(
            row[0], row[2], row[4], row[5], due, row[1]))


def relative_date_to_sql_query(date: str):
    if date[0] == "+":
        return "date('now', '" + date + "')"

    if date == "today":
        return "date('now')"

    if date == "tomorrow":
        return "date('now', '+1 day')"

    return "date('" + date + "')"


def main():
    args = get_arguments()
    set_logging(args.verbose)

    database_file = "/var/lib/aide/tasks.db"
    db = sqlite3.connect(database_file)
    cursor = db.cursor()

    if args.subparser_name == 'add':
        add_task(args, db, cursor)
    elif args.subparser_name == 'list':
        list_tasks(args, cursor)
    elif args.subparser_name == 'mod':
        modify_task(args, db, cursor)
    elif args.subparser_name == 'close':
        close_task(args, db, cursor)
    elif args.subparser_name == 'delete':
        delete_task(args, db, cursor)
    elif args.subparser_name == 'report':
        report(args, cursor)

    db.close()


if __name__ == "__main__":
    main()
