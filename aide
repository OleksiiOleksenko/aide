#!/usr/bin/env python3
import datetime
import logging
import json
import os
import sqlite3

import matplotlib.pyplot as plt

from arguments import get_arguments
from skill import train


def set_logging(verbose=False):
    logging.basicConfig(
        format='[%(levelname)s] %(message)s',
        level=logging.INFO if not verbose else logging.DEBUG,
        datefmt="%m-%d %H:%M:%S"
    )


def add_task(args, db, cursor):
    logging.info("Adding %s; priority %s; due %s %s" % (args.name, args.priority, args.time, args.date))

    priority = args.priority
    if args.time:
        priority += 100

    if args.date:
        date = relative_date_to_sql_query(args.date)
    else:
        date = "date('now')"

    repeat = "+" + args.repeat if args.repeat else None

    cursor.execute("INSERT INTO tasks(name, priority, due_time, due_date, weight, repeat_period) VALUES "
                   "(?, ?, " + local_to_utc("?") + "," + date + ", ?, ?)",
                   (args.name, priority, args.time, args.weight, repeat))
    db.commit()


def list_tasks(args, cursor):
    query = "SELECT id, name, priority, " + utc_to_local("due_time") + ", status, weight FROM tasks WHERE "
    query_arguments = []

    # parametrize a query
    if args.top:
        query = "SELECT id, name, priority, %s, status, weight FROM tasks " \
                "WHERE status=1 AND (due_time < current_time OR due_time IS NULL) AND due_date = current_date " \
                " ORDER BY priority DESC " \
                " LIMIT 1" % utc_to_local("due_time")
    else:
        query = "SELECT id, name, priority, " + utc_to_local("due_time") + ", status, weight FROM tasks WHERE "
        if args.open:
            query += "status=1 AND "

        if args.date:
            date = relative_date_to_sql_query(args.date)
            query += "due_date is " + date if date == "null" else "due_date=" + date
        else:
            query_overdue = query + "due_date<current_date "
            query += "due_date=current_date "

    # run the queries
    if not args.date and not args.top:
        cursor.execute(query_overdue, query_arguments)
        result = cursor.fetchall()
        if result:
            logging.info("Overdue tasks:")
            print_tasks(result, verbose=args.verbose)
            logging.info("Today tasks:")

    cursor.execute(query, query_arguments)
    result = cursor.fetchall()
    print_tasks(result, verbose=args.verbose)


def modify_task(args, db, cursor):
    logging.info("Modifying task: " + args.id)

    setters = []
    query_arguments = []

    if args.name:
        setters.append("name=?")
        query_arguments.append(args.name)

    if args.priority >= 0:
        setters.append("priority=?")
        query_arguments.append(args.priority)

    if args.time:
        setters.append("due_time=" + local_to_utc("?"))
        query_arguments.append(args.time)

    if args.weight >= 0:
        setters.append("weight=?")
        query_arguments.append(args.weight)

    if args.repeat:
        setters.append("repeat_period=?")
        query_arguments.append("+" + args.repeat)

    if args.date:
        date = relative_date_to_sql_query(args.date)
        setters.append("due_date=" + date)

    query = "UPDATE tasks SET " + " AND ".join(setters) + " WHERE id = ?"
    query_arguments.append(args.id)

    cursor.execute(query, query_arguments)
    db.commit()


def close_task(args, db, cursor):
    if args.id:
        id_ = args.id
        cursor.execute("SELECT name FROM tasks WHERE id = ?", (id_,))
        name = cursor.fetchone()[0]
    else:
        cursor.execute("SELECT id, name FROM tasks "
                       "WHERE status=1 AND (due_time < current_time OR due_time IS NULL) AND due_date = current_date "
                       " ORDER BY priority DESC "
                       " LIMIT 1")
        task = cursor.fetchone()
        id_ = task[0]
        name = task[1]
        if not ask_confirmation("Do you want to close \"%s\"?" % name):
            return

    logging.info("Closing task: " + name)

    cursor.execute("UPDATE tasks SET status=0 WHERE id = ?", (id_,))
    db.commit()

    logging.info("Next task:")
    args.top = True
    args.date = True
    list_tasks(args, cursor)


def delete_task(args, db, cursor):
    logging.info("Deleting task: " + args.id)
    cursor.execute("DELETE FROM tasks WHERE id = ?", (args.id,))
    db.commit()


def add_note(args, db, cursor):
    if args.date:
        cursor.execute("INSERT INTO notes(date, text) VALUES (?, ?)", (args.date, args.text))
    else:
        cursor.execute("INSERT INTO notes(date, text) VALUES (date('now'), ?)", (args.text,))
    db.commit()
    logging.info("Note added")


def report(args, cursor):
    if args.plot:
        cursor.execute('SELECT sum(weight),due_date FROM tasks WHERE status=0 GROUP BY due_date')
        data = cursor.fetchall()

        if len(data) <= 2:
            logging.error("Not enough data to build a plot")
            return

        date_start = datetime.datetime.strptime(data[0][1], "%Y-%m-%d")
        date_end = datetime.datetime.strptime(data[-1][1], "%Y-%m-%d")
        dates = [(date_start + datetime.timedelta(days=x)).strftime("%Y-%m-%d") for x in
                 range(0, (date_end - date_start).days + 1)]

        weights = []
        i = 0
        for row in data:
            while row[1] != dates[i]:
                weights.append(0.0)
                i += 1

            weights.append(row[0])
            i += 1

        fig = plt.figure(figsize=(10, 1))
        ax = fig.add_subplot(111)
        ax.bar(dates, weights)
        ax.yaxis.grid(True, linestyle=':', which='major')
        labels = ax.set_xticklabels(dates)
        plt.setp(labels, rotation=90)
        ax.set_aspect(3.)
        plt.show()

        return

    query = "SELECT sum(weight) FROM tasks WHERE due_date=current_date GROUP BY due_date"
    query_arguments = []

    result = cursor.execute(query, query_arguments).fetchone()
    total = result[0] if result else 0.0

    print("Total weight:", total)


def print_tasks(tasks: list, verbose=True):
    if not tasks:
        logging.info("No open tasks")
        return

    # only the name of the task
    if not verbose and len(tasks) == 1:
        print(tasks[0][1])
        return

    # description of a task
    if verbose and len(tasks) == 1:
        row = tasks[0]
        due = row[3] if row[3] else "--:--"
        print("{:<2} | Pr: {:<3} | Status: {} | Weight: {:<4} | Due: {} | {}".format(
            row[0], row[2], row[4], row[5], due, row[1]))
        return

    if verbose:
        print("PR  | ST | WEI  |  DUE  | ID  | Name\n-------------------------------------")

    for row in tasks:
        due = row[3] if row[3] else "--:--"
        print("{:<3} | {:<2} | {:<4} | {} | {:<3} | {}".format(
            row[2], row[4], row[5], due, row[0], row[1]))


def relative_date_to_sql_query(date: str):
    if date[0] == "+":
        return "date('now', '" + date + "')"

    if date == "today":
        return "date('now')"

    if date == "tomorrow":
        return "date('now', '+1 day')"

    if date == "no":
        return "null"

    return "date('" + date + "')"


# SQLite doesn't handle daylight saving properly
# The following 2 functions bypass this limitation
def utc_to_local(time: str):
    return "strftime('%H:%M', " \
           "    strftime('%s', " + time + ") + strftime('%s', 'now', 'localtime') - strftime('%s', 'now'), 'unixepoch')"


def local_to_utc(time: str):
    return "strftime('%H:%M', " \
           "    strftime('%s', " + time + ") + strftime('%s', 'now') - strftime('%s', 'now', 'localtime'), 'unixepoch')"


def read_configuration():
    with open(os.path.expanduser("~/.aide.conf")) as f:
        config = json.load(f)
    return config


def ask_confirmation(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        print(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            print("Please respond with 'yes' or 'no' "
                  "(or 'y' or 'n').\n")


def main():
    set_logging()
    args = get_arguments()
    config = read_configuration()

    database_file = config['db_path']
    db = sqlite3.connect(database_file)
    cursor = db.cursor()

    if args.subparser_name == 'add':
        add_task(args, db, cursor)
    elif args.subparser_name == 'list':
        list_tasks(args, cursor)
    elif args.subparser_name == 'mod':
        modify_task(args, db, cursor)
    elif args.subparser_name == 'close':
        close_task(args, db, cursor)
    elif args.subparser_name == 'delete':
        delete_task(args, db, cursor)
    elif args.subparser_name == 'note':
        add_note(args, db, cursor)
    elif args.subparser_name == 'report':
        report(args, cursor)
    elif args.subparser_name == 'train':
        train(args, db, cursor)

    db.close()


if __name__ == "__main__":
    main()
